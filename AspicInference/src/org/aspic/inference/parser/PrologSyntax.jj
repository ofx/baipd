/*
 * JavaCC (4.0) grammar file for the Argument Engine Prolog syntax.
 * Use this file to generate the JavaCC Parser,
 * i.e. run "./bin/javacc PrologSyntax.jj" at the commandline when 
 * you are in the javacc root directory and this file is also in the root.
 * NB Each generated file has a header: "Generated By:JavaCC: Do not edit this line..."
 * More details about JavaCC can be found at https://javacc.dev.java.net/
 * Tests for this parser can be found in TestPrologSyntax.java.
 *
 * Implementation notes:
 * The condition that "degree of belief" is within the bound (0,1] is enforced
 * in the code, not the parser.  If the beliefToken is outside of this bound
 * then a ParseException is thrown, but this exception doesnt contain the detail
 * that the usual exceptions have.
 *
 * TODO?: Be a bit more careful about the definition of numbers (i.e is 00001.3 a valid number?). nb if you try fixing this with say [1-9] at the front of your integer definition, then you exclude the number "0".
 * TODO: set is, +, -, *, / to be infix expressions. Get left recursion errors if we try it as is.
 */ 

options {
  STATIC = false;
}

PARSER_BEGIN(PrologSyntax)
package org.aspic.inference.parser;

import org.aspic.inference.*;

/**
 * JavaCC generated Parser from grammar file, PrologSyntax.jj.
 * Grammar defines production rules for:
 * <ul>
 * <li>Knowledge - a set of the Expressions</li>
 * <li>Expression - a fact or rule</li>
 * <li>TermList - A list of Terms.  Used for a rule antecedent (and maybe later a query)</li>
 * <li>Term - a fact</li>
 * <li>ParamList - the parameters of a Term</li>
 * <li>Param - a Term parameter (i.e. a Term, a Variable, a Constant, a Number) </li>
 * </ul>
 * @author mjs (matthew.south @ cancer.org.uk)
 */
public class PrologSyntax {
  /**
   * This method allows you to run the parser in command line mode, to test it.
   * It prints a view of the knowledge base when you've finished.
   */
  public static void main(String args[]) throws ParseException {
    PrologSyntax parser = new PrologSyntax(System.in);
    KnowledgeBase kb = parser.Knowledge ();
    System.out.println("Succesfully parsed:\n" + kb.toString());
  }

}

PARSER_END(PrologSyntax)

/* COMMENTS */

SKIP :
{  
  " " |
  "\n" |
  "\t" |
  "\r" |
  "/*" : WithinMultiLineComment
}

<WithinMultiLineComment> SKIP :
{
  "*/" : DEFAULT
}

<WithinMultiLineComment> MORE :
{
  <~[]>
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: ("%"|"#") (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

/* The language */

TOKEN :
{
<PLUS: "+"> 
| <MINUS: "-"> 
| <TIMES: "*"> 
| <DIVIDE: "/">
| <GT: ">">
| <LT: "<">
| <NEG: "~" >
| <ABW: "<-" >
| <GTE: ">=">
| <LTE: "=<">
| <IS: "is" >
| <EQ: "==">
| <NEQ: "\\==">
| <AEQ: "=:=">
| <ANEQ: "=\\=">
| <NONVAR: "nonvar" >
| <NAF: "\\+"> 
| <IDN: ["a"-"z"] ( ["a"-"z","A"-"Z","_","0"-"9"] )* | "'" (  "''" | ~["'"] )+ "'" >
| <VAR: ("_" ( ["0"-"9"] )*) | (["A"-"Z"] ( ["a"-"z","A"-"Z","_","0"-"9"] )*)>
| <INT: ("-")? ["1"-"9"] ( ["0"-"9"] )* | "0" >
| <FLOAT: ("-")? ["0"-"9"] ( ["0"-"9"] )* ( "." ( ["0"-"9"] )* ) >
| <CAPTION: "$" (~["\n","\r", "$"])* "$">
}

KnowledgeBase Knowledge() :
{ 
	KnowledgeBase kb = new KnowledgeBase();
	Rule e1;
}
{
	( e1 = Expression() { kb.addRule(e1); } )* <EOF> { return kb; }
}

Rule Expression() :
{
	Constant name = null;
	Constant con;
	ElementList ant = null;
	Token beliefToken = null;
	Token caption = null;
	Token claimCaption = null;
}
{
	[ "[" name = Term() "]" ] con = Term() [ <ABW> ant = TermList() ] [ beliefToken = <FLOAT> ] "." [ caption = <CAPTION> [ claimCaption = <CAPTION> ]]
	{
		Rule result = null;
		if (beliefToken==null) {
			if (ant==null) {
				if (name==null) {
					// fact
					result = new Rule(con);
				} else {
					// EK: Allow naming of facts
					result = new Rule(con, name);
					// error :: name supplied for fact
					//throw new ParseException("Rule name, " + name.inspect() + " provided for Fact. Only Rules can be named.");  
				}
			} else {
				if (name==null) {
					// strict rule
					result = new Rule(con, ant);
				} else {
					// named strict rule
					result = new Rule(con, ant, 1.0, name);
				}
			}
		} else {
			Double belief = Double.valueOf(beliefToken.image);
			if (belief>0.0 & belief <=1.0) {
				if (ant==null) {
					if (name==null) {
						// belief
						result = new Rule(con, belief);
					} else {
						// EK: Allow naming of facts
						result = new Rule(con, belief, name);
						// error :: name supplied for fact
						//throw new ParseException("Rule name, " + name.inspect() + " provided for Fact. Only Rules can be named.");  
					}
				} else {
					if (name==null) {
						// defeasible rule
						result = new Rule(con, ant, belief);
					} else {
						// named defeasible rule
						result = new Rule(con, ant, belief, name);
					}
				}
			} else {
				throw new ParseException("Found belief of " + beliefToken.image + ". Belief must be in the range (0, 1].");
			}
		}
		if (caption!=null) {
			result.setCaption(caption.image.replace("$", ""));
		}
		if (claimCaption!=null) {
			result.setClaimCaption(claimCaption.image.replace("$", ""));
		}
		return result;
	}
}

/** Added so that a Knowledge Editor can parse isolated Terms **/
Constant IsolatedTermOrBuiltIn() :
{
	Constant term;
	BuiltIn builtIn;
}
{
	term = Term() <EOF> { return term; } 
	| builtIn = BuiltIn() { return builtIn; } <EOF>
}

Constant TermOrBuiltIn() :
{
	Constant term;
	BuiltIn builtIn;
}
{
	term = Term() { return term; } 
	| builtIn = BuiltIn() { return builtIn; }
}

BuiltIn BuiltIn() :
{
	Element operand = null;
	Element left = null;
	Element right = null;
}
{
	<PLUS> "(" left = Param() "," right = Param() ")"
	{
		return new Addition(left, right);
	} |
	<MINUS> "(" left = Param() "," right = Param() ")"
	{
		return new Subtraction(left, right);
	} |
	<TIMES> "(" left = Param() "," right = Param() ")"
	{
		return new Multiplication(left, right);
	} |
	<DIVIDE> "(" left = Param() "," right = Param() ")"
	{
		return new Division(left, right);
	} |
	<IS> "(" left = Param() "," right = Param() ")"
	{
		return new Is(left, right);
	} |
	<GT> "(" left = Param() "," right = Param() ")"
	{
		return new GreaterThan(left, right);
	} |
	<GTE> "(" left = Param() "," right = Param() ")"
	{
		return new GreaterThanOrEqualTo(left, right);
	} |
	<LT> "(" left = Param() "," right = Param() ")"
	{
		return new LessThan(left, right);
	} |
	<LTE> "(" left = Param() "," right = Param() ")"
	{
		return new LessThanOrEqualTo(left, right);
	} |
	<EQ> "(" left = Param() "," right = Param() ")"
	{
		return new EqualTo(left, right);
	} |
	<NEQ> "(" left = Param() "," right = Param() ")"
	{
		return new NotEqualTo(left, right);
	} |
	<AEQ> "(" left = Param() "," right = Param() ")"
	{
		return new ArithmeticEqualTo(left, right);
	} |
	<ANEQ> "(" left = Param() "," right = Param() ")"
	{
		return new ArithmeticNotEqualTo(left, right);
	} |
	<NAF> "(" operand = Param() ")"
	{
		return new NegationAsFailure(operand);
	} |
	<NONVAR> "(" operand = Param() ")"
	{
		return new Nonvar(operand);
	}
}

Constant Term() :
{
	Token idn;
	Token neg = null;
	ElementList params = null;
}
{
	[ LOOKAHEAD(2) neg = <NEG>] idn = <IDN> [ "(" params = ParamList() ")" ] 
	{
		if (params==null) {
			if (neg == null) {
				return new Constant(idn.image);
			} else {
				return new Constant(idn.image).negation();
			}
		} else {
			if (neg == null) {
				return new org.aspic.inference.Term(idn.image, params);
			} else {
				return new org.aspic.inference.Term(idn.image, params).negation();
			}
		}
	}
}

ConstantList TermList() :
{
	ConstantList list = new ConstantList();
	Constant t1;
	Constant t2 = null;
}
{
	t1 = TermOrBuiltIn() { list.add(t1); }  ( "," t2 = TermOrBuiltIn() {list.add(t2); } )* { return list; }
}

ElementList ParamList() :
{
	ElementList list = new ElementList();
	Element p1;
	Element p2 = null;
}
{
	p1 = Param() {	list.add(p1);  } ( "," p2 = Param() { list.add(p2); } )* { return list; }
}

Element Param() :
{
	Token var;
	Token numint;
	Token numfloat;
	Constant term;
	BuiltIn builtIn;
}
{
	var = <VAR> { return new Variable(var.image); } 
| 	numfloat = <FLOAT> { return new ConstantFloat(Double.valueOf(numfloat.image)); }
| 	numint = <INT> { return new ConstantInteger(Integer.valueOf(numint.image)); }
| 	term = Term() { return term; }
|   builtIn = BuiltIn() { return builtIn; }
}

