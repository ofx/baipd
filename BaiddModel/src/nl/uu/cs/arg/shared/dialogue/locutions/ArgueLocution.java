package nl.uu.cs.arg.shared.dialogue.locutions;

import java.util.Set;

import org.aspic.inference.Constant;
import org.aspic.inference.RuleArgument;

/**
 * An argue(A => p) move, where A => p is some argument where the conclusion p
 * is supported by a set of premises and inferences in A.
 * 
 * @author erickok
 *
 */
public class ArgueLocution extends AttackingLocution {

	private static final String LOCUTION_NAME = "argue";

	/**
	 * The argument that supports conclusion p
	 */
	private RuleArgument argument;
	
	public ArgueLocution(RuleArgument argument) {
		super(LOCUTION_NAME);
		this.argument = argument;
	}

	/**
	 * The proof for conclusion p, which forms the argument of this argue move
	 * @return The instantiated rules that form the actual argument
	 */
	public RuleArgument getArgument() {
		return this.argument;
	}
	
	/**
	 * Returns a string of the form 'argue(p &lt;- A)' where A can be a rule or subargument
	 * @return A formatted and human-readable string
	 */
	@Override
	public String toLogicString() {
		/*String arg = printArgAsChain(getArgument());
		if (arg.length() > 0) {
			arg = arg.substring(0, arg.length() - " <- ".length());
		} else {
			arg = getArgument().inspect();
		}*/
		return getName() + "(" + getArgument().inspect() + ")";
	}

	/*private String printArgAsChain(RuleArgument arg) {
		String out = (!arg.isAtomic() || arg.getClaim() instanceof Term)? 
				arg.getClaim().inspect() + " <- ": "";
		for (RuleArgument sub : arg.getSubArgumentList().getArguments()) {
			out += printArgAsChain(sub);
		}
		return out;
	}*/

	/**
	 * Find the used beliefs in this arguments (premises and rules) recursively
	 */
	@Override
	public void gatherPublicBeliefs(Set<Constant> exposedBeliefs) {
		gatherArgumentBeliefs(exposedBeliefs, this.argument);
	}
	
	/**
	 * Find the used beliefs in this arguments (premises and rules) recursively
	 * @param publicBeliefs The beliefs that are already gathered
	 * @param argument The (sub-)argument that we currently consider
	 */
	private void gatherArgumentBeliefs(Set<Constant> publicBeliefs, RuleArgument argument) {
		
		if (!argument.isAtomic()) {
			// Add the inference rule used
			publicBeliefs.add(argument.getTopRule());
			// Add the premises and inference rules of its subarguments
			for (RuleArgument sub : argument.getSubArgumentList().getArguments()) {
				gatherArgumentBeliefs(publicBeliefs, sub);
			}
		} else {
			// Add the premise
			if (!argument.getTopRule().isAutoGenerated())
				publicBeliefs.add(argument.getClaim());
		}
		
	}

	@Override
	public String toSimpleString() {
		return "argue " + getArgument().toSimpleString();
	}

}
